const { $exe, $fs, $io, le } = window,
      AsarHandler = require('./AsarHandler'),
      constants = require('../util/constants'),
      Loader = require('../util/Loader'),
      PathUtil = require('../util/PathUtil')

const { utils } = $fs,
      { configPath } = constants.bundle,
      { app } = constants,
      ownWindow = window

const toArrayBuffer = buffer => {
  const arraybuffer = new ArrayBuffer(buffer.length),
        view = new Uint8Array(arraybuffer)

  for(const i in buffer)
    view[i] = buffer[i]

  return arraybuffer
}

class BundleHandler extends AsarHandler {
  constructor(buffer, path) {
    super(buffer)

    const exists = super.exists(configPath)

    if(exists) {
      const configRaw = super.get(configPath).toString('utf-8')

      this.config = JSON.parse(configRaw)
    } else {
      throw app.errors.configError('No config file was found.')
    }

    this.path = path
    this.cache = new Map()
  }

  async start() {
    const { entry } = this.config,
          isFile = entry.startsWith('/')

    if(typeof entry !== 'string')
      throw app.errors.configError('Bundle entry invalid or not found.')

    if(isFile) {
      const mimetype = le._get.ext.mime[utils.getExt(entry)],
            path = utils.resolvePath(entry)

      if(mimetype != 'application/javascript')
        app.errors.configError(`Cannot handle entry files of type "${mimetype}".`)

      this.loadScript(path)
    } else {
      $exe(entry)
    }
  }

  async open(path, format) {
    let arraybuffer = this.cache.get(path)

    if(!arraybuffer) {
      const buffer = super.get(path)

      arraybuffer = toArrayBuffer(buffer)
      this.cache.set(path, arraybuffer)
    }

    const ext = utils.getExt(path),
          blob = new Blob([ arraybuffer ], { type: le._get.ext.mime[ext] })

    switch(format) {
      case 'ArrayBuffer':
        return arraybuffer

      case 'Blob':
        return blob

      case 'ObjectURL':
        return URL.createObjectURL(blob)

      default:
        const toFormat = $io.Blob[format]

        if(!toFormat)
          throw new Error(`Invalid format "${format}"`)

        const executor = (resolve, reject) => {
          const onSuccess = (...args) =>
            resolve(...args)

          const onError = (...args) =>
            reject(...args)

          const data = toFormat(blob, onSuccess, onError)
        }

        return await new Promise(executor)
    }
  }

  // Returns a promise
  loadScript(path, window = ownWindow) {
    // Refactor this: use function constructor for `modified`, make apiLocation 
    // generated by it's own function with all of the external data needed as
    // arguments. These can be passed with an array and JSON.stringify used.
    //
    // Done?

    const getAPI = (scope, app, index, path) =>
      scope.le._apps[app].ScriptAPI.from(index, path)

    const format = args =>
      args.map(JSON.stringify).join(', ')

    const script = this.get(path).toString('utf-8'),
          scope = window.parent == ownWindow ? 'this.parent' : 'this',
          dirPath = PathUtil.join(path, '../'),
          args = [ app.id, le._bundles.length, dirPath ],
          func = new Function('$bundle', script)
          
    const api = `(${getAPI})(${scope}, ${format(args)})`,
          code = `(${func}).call(this, ${api})`,
          blob = new Blob([ code ], { type: 'application/javascript' }),
          url = URL.createObjectURL(blob)

    window.le._bundles.push(this)
    return new Loader(window.document).script(url)
  }
}

module.exports = BundleHandler